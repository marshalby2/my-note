# Storage Class
{: id="20201022205527-1wd0l6h"}

### Scope
{: id="20201022210324-7yq54dg"}

Scope describes the region or regions of a program that can access an identifier. A C variable
has one of the following scopes: block scope, function scope, function prototype scope, or file
scope.
{: id="20201022210330-59itslh"}

##### block scope
{: id="20201022210655-00a6j7w"}

the variables cleo and patrick in the following code both have block scope extending to the closing
brace:
{: id="20201022210521-r7kc4bm"}

```c
double blocky(double cleo)
{
double patrick = 0.0;
...
return patrick;
}
```
{: id="20201022210344-des4rkj"}

##### file scope
{: id="20201022205541-3rgdutb"}

A variable with its definition placed outside of any function has file scope. A variable with file
scope is visible from the point it is defined to the end of the file containing the definition. Take
a look at this example
{: id="20201022210716-kp0ysml"}

```
#include <stdio.h>
int units = 0; /* a variable with file scope */
void critic(void);
int main(void)
{
...
}
```
{: id="20201022210720-dx41igf"}

##### 
{: id="20201022210739-u3c8wvm"}

{: id="20201022211023-wfgcxpt"}

{: id="20201022211023-8lc1j9g"}

### Linkage
{: id="20201022211023-eg4gzez"}

Next, letâ€™s look at linkage. A C variable has one of the following linkages: external linkage,
internal linkage, or no linkage. Variables with block scope, function scope, or function prototype scope have no linkage. That means they are private to the block, function, or prototype in
which they are defined. A variable with file scope can have either internal or external linkage.
A variable with external linkage can be used anywhere in a multifile program. A variable with
internal linkage can be used anywhere in a single translation unit.
{: id="20201022211026-a910iie"}
