# 一、概述
{: id="20201229150349-dpi9bfr"}

Java 虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这个过程被称作虚拟机的类加载机制。与那些在编译时需要进行连接的语言不同，在 Java 语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成的，这种策略让 Java 语言进行提前编译会面临额外的困难，也会让类加载时稍微增加一些性能开销，但是却为 Java 应用提供了极高的扩展性和灵活性，Java 天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。
{: id="20201229150429-7d5so5f"}

# 二、类加载时机
{: id="20201229150725-0c675de"}

一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）七个阶段，其中验证、准备、解析三个部分统称为连接（Linking）。这七个阶段的发生顺序如图 7-1 所示。
{: id="20201229150741-25x64b1"}

![71.png](assets/20201229150844-jubvobc-7-1.png)
{: id="20201229150753-12cnmnj"}

{: id="20201229153756-5drw5db"}

其中，加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类型的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 语言的运行时绑定特性（也称为动态绑定或晚期绑定）。
{: id="20201229153757-jnsaro3"}

对于初始化阶段，《Java 虚拟机规范》则是严格规定了有且只有六种情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）：
{: id="20201229153808-3fv4iz1"}

**（1）** 遇到 new、getstatic、putstatic 或 invokestatic 这四条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段。能够生成这四条指令的典型 Java 代码场景有：
{: id="20201229153915-ec7468a"}

- {: id="20201229154102-f44w0rf"}使用 new 关键字实例化对象的时候。
- {: id="20201229154113-yglvrt1"}读取或设置一个类型的静态字段（被 final 修饰、已在编译器把结果放入常量池的静态字段除外）的时候。
- {: id="20201229154159-89vj0ra"}调用一个类型的静态方法的时候。
{: id="20201229154058-oj0vtvo"}

**（2）** 使用 java.lang.reflect 包的方法对类型进行反射调用的时候，如果类型没有进行初始化，则需要先触发其初始化。
{: id="20201229154212-cz5l2de"}

**（3）** 当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
{: id="20201229154305-ri8d3ue"}

**（4）** 当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个类。
{: id="20201229154345-zsxrgzn"}

**（5）** 当使用 JDK 7 新加入的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial 四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。
{: id="20201229154449-nhgzjsj"}

**（6）** 当一个接口中定义了 JDK 8 新加入的默认方法（被 default 关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。
{: id="20201229154500-i4bh32w"}

对于这六种会触发类型进行初始化的场景，《Java 虚拟机规范》中使用了一个非常强烈的限定语——“有且只有”，这六种场景中的行为称为对一个类型进行主动引用。除此之外，所有引用类型的方式都不会触发初始化，称为被动引用。
{: id="20201229154634-txbzfsp"}

接口的加载过程与类加载过程稍有不同，针对接口需要做一些特殊说明：接口也有初始化过程，这点与类是一致的，上面的代码都是用静态语句块“static{}”来输出初始化信息的，而接口中不能使用“static{}”语句块，但编译器仍然会为接口生成“<clinit>()”类构造器[插图]，用于初始化接口中所定义的成员变量。 **接口与类真正有所区别的是前面讲述的六种“有且仅有”需要触发初始化场景中的第三种：当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始化。**
{: id="20201229154636-k87vws9"}

{: id="20201229155755-7mg9u2l"}

# 三、类加载过程
{: id="20201229160007-4ii9lxx"}

### 3.1 加载
{: id="20201229160012-vb3hst2"}

“加载”（Loading）阶段是整个“类加载”（Class Loading）过程中的一个阶段，希望读者没有混淆这两个看起来很相似的名词。在加载阶段，Java 虚拟机需要完成以下三件事情：
{: id="20201229160047-3488aik"}

**（1）** 通过一个类的全限定名来获取定义此类的二进制字节流。
{: id="20201229160056-x4sqzrl"}

**（2）** 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
{: id="20201229160121-ncuaqys"}

**（3）** 在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。
{: id="20201229160125-jr94x61"}
