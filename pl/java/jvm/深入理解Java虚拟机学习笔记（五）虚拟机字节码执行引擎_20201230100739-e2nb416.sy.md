# 一、概述
{: id="20201230100739-g4j1fao"}

**执行引擎** 是 Java 虚拟机核心的组成部分之一。“虚拟机”是一个相对于“物理机”的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的，而虚拟机的执行引擎则是由软件自行实现的，因此可以不受物理条件制约地定制指令集与执行引擎的结构体系，能够执行那些不被硬件直接支持的指令集格式。
{: id="20201230100751-p7sbyyp"}

在不同的虚拟机实现中，执行引擎在执行字节码的时候，通常会有 **解释执行（通过解释器执行）** 和 **编译执行（通过即时编译器产生本地代码执行）** 两种选择，也可能两者兼备，还可能会有同时包含几个不同级别的即时编译器一起工作的执行引擎。但从外观上来看， **所有的 Java 虚拟机的执行引擎输入、输出都是一致的：输入的是字节码二进制流，处理过程是字节码解析执行的等效过程，输出的是执行结果，** 本章将主要从概念模型的角度来讲解虚拟机的方法调用和字节码执行。
{: id="20201230100809-pfbfcy1"}

# 二、运行时栈帧结构
{: id="20201230100850-tu5t00e"}

**Java 虚拟机以方法作为最基本的执行单元，“栈帧”（Stack Frame）则是用于支持虚拟机进行方法调用和方法执行背后的数据结构，它也是虚拟机运行时数据区中的虚拟机栈（Virtual Machine Stack）的栈元素。**
{: id="20201230100957-jzbl2lb"}

每一个方法从调用开始至执行结束的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。
{: id="20201230101019-ik8lu1e"}

**每一个栈帧都包括了局部变量表、操作数栈、动态连接、方法返回地址和一些额外的附加信息。在编译 Java 程序源码的时候，栈帧中需要多大的局部变量表，需要多深的操作数栈就已经被分析计算出来，并且写入到方法表的 Code 属性之中。换言之，一个栈帧需要分配多少内存，并不会受到程序运行期变量数据的影响，而仅仅取决于程序源码和具体的虚拟机实现的栈内存布局形式。**
{: id="20201230101102-hcovyel"}

图 8-1 所示的就是虚拟机栈和栈帧的总体结构：
{: id="20201230101236-ham3cwx"}

![81.png](assets/20201230101213-ckds1tr-8-1.png)
{: id="20201230101143-dp8q0fa"}

{: id="20201230101240-o27bu67"}

### 2.1 局部变量表
{: id="20201230101240-xn8h498"}

**局部变量表（Local Variables Table）是一组变量值的存储空间，用于存放方法参数和方法内部定义的局部变量。在 Java 程序被编译为 Class 文件时，就在方法的 Code 属性的 max_locals 数据项中确定了该方法所需分配的局部变量表的最大容量。**
{: id="20201230101252-9p7ed93"}

{: id="20201230101312-fzggptn"}
