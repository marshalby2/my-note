# 前言
{: id="20201106111403-h3vcjxv"}

并发编程属于编程技能里的高阶技能，并发编程是迈向高级程序员必须掌握的，在学习并发编程之前，需要做好一些知识储备工作，本篇文章是总结了学习并发编程之前所需要了解的一些基本知识。
{: id="20201106111403-wocwf3v"}

# 并发编程里的一些术语解释
{: id="20201106111403-s6g800f"}

### 进程
{: id="20201106111403-ybo6hr1"}

**进程（Process）** 是指计算机中已运行的程序，是操作系统资源分配的基本单位。程序本身只是指令、数据及其组织形式的描述，进程才是程序（那些指令和数据）的真正运行实例。
{: id="20201106111403-hl1tjpg"}

**作用**：在最开始的时候，计算机没有操作系统，一台计算机在同一时刻只能运行一个程序，因此计算机的资源利用率会很低下。后来随着操作系统的发展，引入了进程这个概念，将计算机中运行的单个程序以及操作系统给该程序分配的资源（比如内存、I/O、处理器等）抽象为一个进程。有了进程以后，一台计算机可以“**同时**”运行多个程序，这样带来的好处是，加入程序A需要进行一些耗时的操作，比如读取文件，这时可以让其他程序运行，从而提升了资源利用率。
{: id="20201106111403-glg3ffk"}

### 线程
{: id="20201106111403-muumy1q"}

**线程（Thread）** 是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以**并发**多个线程，每条线程并行执行不同的任务。
{: id="20201106111403-w8owsps"}

### 并发
{: id="20201106111403-ht4afu7"}

**并发（concurrency）** 在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行，但任一个时刻点上只有一个程序在处理机上运行。
{: id="20201106111403-jxyddxl"}

### 并行
{: id="20201106111403-kgzr549"}

**并行（Parallerl）** 在操作系统中是指，一组程序按独立异步的速度执行，无论从微观还是宏观，程序都是一起执行的
{: id="20201106111403-0pt1j73"}

### 并发和并行的区别
{: id="20201106111403-bovyqx7"}

并发和并行是即相似又有区别的两个概念，并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔内发生。在多道程序环境下，并发性是指在一段时间内宏观上有多个程序在同时运行，但在单处理机系统中，每一时刻却仅能有一道程序执行，故微观上这些程序只能是分时地交替执行。倘若在计算机系统中有多个处理机，则这些可以并发执行的程序便可被分配到多个处理机上，实现并行执行，即利用每个处理机来处理一个可并发执行的程序，这样，多个程序便可以同时执行。
{: id="20201106111403-dczgr0x"}

### 同步
{: id="20201106111403-byhrl7r"}

按照顺序执行方法，一个方法执行完，再执行下一个方法。
{: id="20201106111403-h3km126"}

### 异步
{: id="20201106111403-qg25bn6"}

在执行一个方法等待返回结果的这个过程里，可以执行其他方法。
{: id="20201106111403-1cv7bq6"}

# 为什么要使用多线程
{: id="20201106111403-l8le5hm"}

在编程的时候，合理的使用多线程可以提升软件的性能，但是随之而来的就是一系列的并发问题。
{: id="20201106111403-hhi35jp"}

# 并发问题的根源
{: id="20201106111403-7cq7dis"}

### 1. 缓存导致的可见性问题
{: id="20201106111403-jthr5kj"}

我们假设线程 A 和线程 B 同时开始执行，那么第一次都会将 count=0 读到各自的 CPU 缓存里，执行完 count+=1 之后，各自 CPU 缓存里的值都是 1，同时写入内存后，我们会发现内存中是 1，而不是我们期望的 2。
{: id="20201106111403-bf4xp55"}

### 2. 线程切换带来的原子性问题
{: id="20201106111403-bl6jlzx"}

高级语言里一条语句往往需要多条 CPU 指令完成，例如 `count += 1`，至少需要三条 CPU 指令。
{: id="20201106111403-3wg91jv"}

- {: id="20201106111403-pulb74m"}指令 1：首先，需要把变量 count 从内存加载到 CPU 的寄存器；
- {: id="20201106111403-sunbn5f"}指令 2：之后，在寄存器中执行 +1 操作；
- {: id="20201106111403-88n0j17"}指令 3：最后，将结果写入内存（缓存机制导致可能写入的是 CPU 缓存而不是内存）。
{: id="20201106111403-zt1vaek"}

### 3. 编译器优化带来的有序性问题
{: id="20201106111403-uvbp89a"}

# Java如何解决并发问题
{: id="20201106111403-chzh1o3"}

Java提供了以下几种方式来解决并发问题
{: id="20201106111403-1q2pg1w"}

### synchronized、 volatile、final 三个关键字
{: id="20201106111403-8s09vre"}

1. {: id="20201106111403-sps97rb"}synchronized块可以保证原子性和可见性。
2. {: id="20201106111403-0bvyjx9"}volatile关键字修饰变量，保证该变量的可见性，即所有线程都能看到它的值
{: id="20201106111403-mz7xu1a"}

### Happens-Before 规则
{: id="20201106111403-al2fj5k"}

Happens-Before 并不是说前面一个操作发生在后续操作的前面，它真正要表达的是：前面一个操作的结果对后续操作是可见的
{: id="20201106111403-i9fkfhn"}

##### 程序顺序规则
{: id="20201106111403-zdgtr82"}

这条规则是指在一个线程中，按照程序顺序，前面的操作 Happens-Before 于后续的任意操作也就是说即程序前面对某个变量的修改一定是对后续操作可见的。
{: id="20201106111403-y0rlrw5"}

##### volatile 变量规则
{: id="20201106111403-bw4dk93"}

对一个volatile域的写，happens- before于任意后续对这个volatile域的读。
{: id="20201106111403-12yca8z"}

##### 传递性
{: id="20201106111403-v3zxn72"}

如果A happens-before B，且B happens-before C，那么Ahappens-before C。
{: id="20201106111403-15glnz8"}

##### 管程中锁的规则
{: id="20201106111403-ov6cgm3"}

这条规则是指对一个锁的解锁 Happens-Before 于后续对这个锁的加锁。
{: id="20201106111403-ow8dbyq"}

##### 线程 start() 规则
{: id="20201106111403-000jyyi"}

这条是关于线程启动的。它是指主线程 A 启动子线程 B 后，子线程 B 能够看到主线程在启动子线程 B 前的操作。换句话说就是，如果线程 A 调用线程 B 的 start() 方法（即在线程 A 中启动线程 B），那么该 start() 操作 Happens-Before 于线程 B 中的任意操作
{: id="20201106111403-sxgtfej"}

##### 线程 join() 规则
{: id="20201106111403-17rnmbm"}

这条是关于线程等待的。它是指主线程 A 等待子线程 B 完成（主线程 A 通过调用子线程 B 的 join() 方法实现），当子线程 B 完成后（主线程 A 中 join() 方法返回），主线程能够看到子线程的操作。当然所谓的“看到”，指的是对共享变量的操作。换句话说就是，如果在线程 A 中，调用线程 B 的 join() 并成功返回，那么线程 B 中的任意操作 Happens-Before 于该 join() 操作的返回
{: id="20201106111403-jqab32x"}

# 安全性、活跃性、
{: id="20201106111403-nhpbog4"}

# 参考
{: id="20201106111403-d902myc"}

1. {: id="20201106111403-rt9e1x9"}[codercc-并发编程](https://www.codercc.com/backend/basic/juc/)
2. {: id="20201106111403-53a2lwa"}[java并发编程体系](https://www.pdai.tech/md/java/thread/java-thread-x-overview.html)
{: id="20201106111403-lomugs4"}
