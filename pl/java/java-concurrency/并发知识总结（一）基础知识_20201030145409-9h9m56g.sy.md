# 前言
{: id="20201103151624-10y4u81"}

并发编程属于编程技能里的高阶技能，并发编程是迈向高级程序员必须掌握的，在学习并发编程之前，本篇文章是总结了学习并发编程之前所需要了解的一些基本知识。
{: id="20201103151627-fxo1p0b"}

# 并发编程里的一些术语解释
{: id="20201030145411-t67k6lw"}

### 进程
{: id="20201030165848-gb5d49f"}

**进程（Process）** 是指计算机中已运行的程序，是操作系统资源分配的基本单位。程序本身只是指令、数据及其组织形式的描述，进程才是程序（那些指令和数据）的真正运行实例。
{: id="20201030170627-7y6a2xz"}

**作用**：在最开始的时候，计算机没有操作系统，一台计算机在同一时刻只能运行一个程序，因此计算机的资源利用率会很低下。后来随着操作系统的发展，引入了进程这个概念，将计算机中运行的单个程序以及操作系统给该程序分配的资源（比如内存、I/O、处理器等）抽象为一个进程。有了进程以后，一台计算机可以“**同时**”运行多个程序，这样带来的好处是，加入程序A需要进行一些耗时的操作，比如读取文件，这时可以让其他程序运行，从而提升了资源利用率。
{: id="20201031094504-k4o60uw"}

### 线程
{: id="20201031093037-y6v6o7d"}

**线程（Thread）** 是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以**并发**多个线程，每条线程并行执行不同的任务。
{: id="20201030170652-ujhnnoz"}

### 并发
{: id="20201030163341-vvn0dpi"}

**并发（concurrency）** 在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行，但任一个时刻点上只有一个程序在处理机上运行。
{: id="20201103152441-476e47c"}

### 并行
{: id="20201030163357-fc6knnm"}

**并行（Parallerl）** 在操作系统中是指，一组程序按独立异步的速度执行，无论从微观还是宏观，程序都是一起执行的。而并发是指：在同一个时间段内，两个或多个程序执行，有时间上的重叠(宏观上是同时，微观上仍是顺序执行)。
{: id="20201030165838-gn32gr2"}

### 并发和并行的区别
{: id="20201031102449-1kn9bf0"}

并发和并行是即相似又有区别的两个概念，并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔内发生。在多道程序环境下，并发性是指在一段时间内宏观上有多个程序在同时运行，但在单处理机系统中，每一时刻却仅能有一道程序执行，故微观上这些程序只能是分时地交替执行。倘若在计算机系统中有多个处理机，则这些可以并发执行的程序便可被分配到多个处理机上，实现并行执行，即利用每个处理机来处理一个可并发执行的程序，这样，多个程序便可以同时执行。
{: id="20201031102506-f8wl7pi"}

### 同步
{: id="20201031102531-nrt81ns"}

按照顺序执行方法，一个方法执行完，再执行下一个方法。
{: id="20201031102541-69owisd"}

### 异步
{: id="20201031102535-frbxfv5"}

在执行一个方法等待返回结果的这个过程里，可以执行其他方法。
{: id="20201031103004-hjag8u0"}

# 并发编程需要解决什么问题
{: id="20201103152631-1wtn67x"}

### 1. 缓存导致的可见性问题
{: id="20201103152849-jkkfw40"}

我们假设线程 A 和线程 B 同时开始执行，那么第一次都会将 count=0 读到各自的 CPU 缓存里，执行完 count+=1 之后，各自 CPU 缓存里的值都是 1，同时写入内存后，我们会发现内存中是 1，而不是我们期望的 2。
{: id="20201103152839-6sb2hgj"}

### 2. 线程切换带来的原子性问题
{: id="20201103152839-hiw5m3y"}

高级语言里一条语句往往需要多条 CPU 指令完成，例如 `count += 1`，至少需要三条 CPU 指令。
{: id="20201103152839-sdovv54"}

- {: id="20201103152839-jssy6j0"}指令 1：首先，需要把变量 count 从内存加载到 CPU 的寄存器；
- {: id="20201103152839-1l9nnfo"}指令 2：之后，在寄存器中执行 +1 操作；
- {: id="20201103152839-f1tpsm8"}指令 3：最后，将结果写入内存（缓存机制导致可能写入的是 CPU 缓存而不是内存）。
{: id="20201103152839-kgrye74"}

### 3. 编译器优化带来的有序性问题
{: id="20201103152839-ruf004m"}

# Java如何解决并发问题
{: id="20201103152958-ipytrtn"}

Java提供了以下几种方式来解决并发问题
{: id="20201104092703-dfrmul5"}

### synchronized
{: id="20201104092940-0xv9okn"}

synchronized块可以保证原子性，
{: id="20201104093005-y496iqj"}

{: id="20201105104027-3fs1wf4"}
