# 并发问题的源头
{: id="20201102141333-casvohw"}

### 1. 缓存导致的可见性问题
{: id="20201102141352-70z6mf6"}

{: id="20201102141526-81o3s2z"}

### 2. 线程切换带来的原子性问题
{: id="20201102141407-9w6o69p"}

任务切换的时机大多数是在时间片结束的时候，我们现在基本都使用高级语言编程，高级语言里一条语句往往需要多条 CPU 指令完成，例如上面代码中的count += 1，至少需要三条 CPU 指令。
{: id="20201102141650-cw5kzcf"}

- 指令 1：首先，需要把变量 count 从内存加载到 CPU 的寄存器；
- 指令 2：之后，在寄存器中执行 +1 操作；
- 指令 3：最后，将结果写入内存（缓存机制导致可能写入的是 CPU 缓存而不是内存）。
{: id="20201102141652-dgeih79"}

{: id="20201102141718-3z94lp7"}

### 3. 编译器优化带来的有序性问题
{: id="20201102141448-rmirph2"}

{: id="20201102141524-roskhh4"}
