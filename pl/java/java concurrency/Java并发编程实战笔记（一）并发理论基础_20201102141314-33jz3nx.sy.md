# 并发问题的源头
{: id="20201102141333-casvohw"}

### 1. 缓存导致的可见性问题
{: id="20201102141352-70z6mf6"}

我们假设线程 A 和线程 B 同时开始执行，那么第一次都会将 count=0 读到各自的 CPU 缓存里，执行完 count+=1 之后，各自 CPU 缓存里的值都是 1，同时写入内存后，我们会发现内存中是 1，而不是我们期望的 2。
{: id="20201102141526-81o3s2z"}

### 2. 线程切换带来的原子性问题
{: id="20201102141407-9w6o69p"}

任务切换的时机大多数是在时间片结束的时候，我们现在基本都使用高级语言编程，高级语言里一条语句往往需要多条 CPU 指令完成，例如上面代码中的count += 1，至少需要三条 CPU 指令。
{: id="20201102141650-cw5kzcf"}

- 指令 1：首先，需要把变量 count 从内存加载到 CPU 的寄存器；
- 指令 2：之后，在寄存器中执行 +1 操作；
- 指令 3：最后，将结果写入内存（缓存机制导致可能写入的是 CPU 缓存而不是内存）。
{: id="20201102141652-dgeih79"}

### 3. 编译器优化带来的有序性问题
{: id="20201102141448-rmirph2"}

{: id="20201102141854-ka7ymqs"}

# Java内存模型
{: id="20201102141524-roskhh4"}

你已经知道，导致可见性的原因是缓存，导致有序性的原因是编译优化，那解决可见性、有序性最直接的办法就是禁用缓存和编译优化，但是这样问题虽然解决了，我们程序的性能可就堪忧了。
合理的方案应该是按需禁用缓存以及编译优化。
{: id="20201102141904-fmm3jod"}

Java 内存模型是个很复杂的规范，可以从不同的视角来解读，站在我们这些程序员的视角，本质上可以理解为，Java 内存模型规范了 JVM 如何提供按需禁用缓存和编译优化的方法。具体来说，这些方法包括 volatile、synchronized 和 final 三个关键字，以及六项 Happens-Before 规则，
{: id="20201102142022-1evpl5w"}

### 1. Volatile
{: id="20201102142927-duj7i2a"}

### Happens-Before 规则2.
{: id="20201102142953-hc8xvte"}
