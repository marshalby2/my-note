# 一、时间复杂度
{: id="20201231092718-9o4bauk"}

# 二、时间复杂度分析
{: id="20201231092730-p7hjlxw"}

1. {: id="20201231092743-hakt449"}只关注循环次数最多的一行代码
2. {: id="20201231092744-uyy493m"}加法法则：总复杂度等于量级最大的那段代码的复杂度
3. {: id="20201231092752-fab4rk3"}乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积
{: id="20201231092738-k9csdup"}

# 三、几种常见的时间复杂度实例分析
{: id="20201231092851-fnmisjq"}

### 1. O(1)
{: id="20201231092907-yzj92qs"}

首先你必须明确一个概念，O(1) 只是常量级时间复杂度的一种表示方法，并不是指只执行了一行代码。比如这段代码，即便有 3 行，它的时间复杂度也是 O(1），而不是 O(3)。
{: id="20201231092951-e1p1w21"}

```c
int i = 8;
int j = 9;
int sum = i + j;
```
{: id="20201231093004-1ibzbvd"}

**一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是 Ο(1)。**
{: id="20201231093116-miy7uwm"}

### 2. O(logn)、O(nlogn)
{: id="20201231093022-onh5dqk"}

对数阶时间复杂度非常常见，同时也是 **最难分析** 的一种时间复杂度。我通过一个例子来说明一下。
{: id="20201231093056-aoigvj3"}

```c
int i = 1;
while (i < n) {
    i = i * 2;
}
```
{: id="20201231093209-qomg3uy"}

从代码中可以看出，变量 i 的值从 1 开始取，每循环一次就乘以 2。当大于 n 时，循环结束。还记得我们高中学过的等比数列吗？实际上，变量 i 的取值就是一个等比数列。如果我把它一个一个列出来，就应该是这个样子的：
{: id="20201231093227-v7oj50k"}

![9b1c88264e7a1a20b5954be9bc4bec9a.jpg](assets/20201231093453-ehignrf-9b1c88264e7a1a20b5954be9bc4bec9a.jpg)
{: id="20201231093346-iw0ghys"}

所以，我们只要知道 x 值是多少，就知道这行代码执行的次数了。通过 2x=n 求解 x 这个问题我们想高中应该就学过了，我就不多说了。x=log2n，所以，这段代码的时间复杂度就是 O(log2n)。
{: id="20201231093455-v0o3dl4"}

### 3. O(m+n)、O(m*n)
{: id="20201231093507-4mf8kc4"}

我们再来讲一种跟前面都不一样的时间复杂度，代码的复杂度由两个数据的规模来决定。老规矩，先看代码！
{: id="20201231093830-n36pdfm"}

```c
int cal(int m, int n) {
        int sum_1 = 0;
        int i = 1;
        for (; i < m; ++i) {
            sum_1 = sum_1 + i;
        }

        int sum_2 = 0;
        int j = 1;
        for (; j < n; ++j) {
            sum_2 = sum_2 + j;
        }
        return sum_1 + sum_2;
    }
```
{: id="20201231093920-460x3a4"}

# 最好、最坏情况时间复杂度
{: id="20201231094028-d5facva"}

# 均摊时间复杂度
{: id="20201231094215-2n2bow1"}

{: id="20201231094426-wdnlzym"}
