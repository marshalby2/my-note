# 一、时间复杂度

# 二、时间复杂度分析

1. 只关注循环次数最多的一行代码
2. 加法法则：总复杂度等于量级最大的那段代码的复杂度
3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

# 三、几种常见的时间复杂度实例分析

### 1. O(1)

首先你必须明确一个概念，O(1) 只是常量级时间复杂度的一种表示方法，并不是指只执行了一行代码。比如这段代码，即便有 3 行，它的时间复杂度也是 O(1），而不是 O(3)。

```c
int i = 8;
int j = 9;
int sum = i + j;
```

**一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是 Ο(1)。**

### 2. O(logn)、O(nlogn)

对数阶时间复杂度非常常见，同时也是 **最难分析** 的一种时间复杂度。我通过一个例子来说明一下。

```c
int i = 1;
while (i < n) {
    i = i * 2;
}
```

从代码中可以看出，变量 i 的值从 1 开始取，每循环一次就乘以 2。当大于 n 时，循环结束。还记得我们高中学过的等比数列吗？实际上，变量 i 的取值就是一个等比数列。如果我把它一个一个列出来，就应该是这个样子的：

![9b1c88264e7a1a20b5954be9bc4bec9a.jpg](assets/20201231093453-ehignrf-9b1c88264e7a1a20b5954be9bc4bec9a.jpg)

所以，我们只要知道 x 值是多少，就知道这行代码执行的次数了。通过 2x=n 求解 x 这个问题我们想高中应该就学过了，我就不多说了。x=log2n，所以，这段代码的时间复杂度就是 O(log2n)。

### 3. O(m+n)、O(m*n)

我们再来讲一种跟前面都不一样的时间复杂度，代码的复杂度由两个数据的规模来决定。老规矩，先看代码！

```c
int cal(int m, int n) {
        int sum_1 = 0;
        int i = 1;
        for (; i < m; ++i) {
            sum_1 = sum_1 + i;
        }

        int sum_2 = 0;
        int j = 1;
        for (; j < n; ++j) {
            sum_2 = sum_2 + j;
        }
        return sum_1 + sum_2;
    }
```

# 最好、最坏情况时间复杂度

# 均摊时间复杂度
